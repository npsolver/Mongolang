repo.users.find({ age: { $gt: 20 } })

The scanner takes the query and gives you a sequence of tokens using a DFA.

Tokens = Terminal Symbols 

id dot id dot id 
firstbracketleft 
   secondbracketleft 
      id colon 
         secondbracketleft 
            dollarsign id colon int 
         secondbracketright 
   secondbracketright 
firstbracketright

Parser also uses a DFA? 

There are non-terminal symbols.

Start symbol: query 




After Scanning we get ->>>>>>>

db.users.find({ age: { $gt: 20 } })

ID db
DOT .
ID users
DOT .
ID find
FIRSTBRACKETLEFT (
SECONDBRACKETLEFT {
ID age
COLON :
SECONDBRACKETLEFT {
DOLLARSIGN $
ID gt
COLON :
INT 20
SECONDBRACKETRIGHT }
SECONDBRACKETRIGHT }
FIRSTBRACKETRIGHT )


Parsing ->>>>>>>





a-z A-Z 0-9 ( ) { } [ ] , : . " $ _


These are Char s (each of them is a byte)

Terminal Symbol -> ID, INT, FIRSTBRACKETLEFT, etc. 
Has name, value

NonTerminal Symbol -> Database, Collection, etc.
Has name 



type Char byte 

type Symbol struct {
    name string
    val  string 
    isTerminal string
}

So that a Context Free Syntax can have both together







Parsing





COMMAND -> DBNAME DOT COLLECTIONNAME DOT COLLECTIONCOMMAND
COLLECTIONCOMMAND -> ID FIRSTBRACKETLEFT OPTIONS FIRSTBRACKETRIGHT
OPTIONS -> EMPTY
OPTIONS -> OPTIONLIST 
OPTIONLIST -> OPTION 
OPTIONLIST -> OPTION COMMA OPTIONLIST
DBNAME -> ID 
OPTION -> SET
SET -> SECONDBRACKETLEFT FIELDS SECONDBRACKETRIGHT
FIELDS -> EMPTY 
FIELDS -> FIELDLIST 
FIELDLIST -> FIELDITEM 
FIELDLIST -> FIELDITEM COMMA FIELDLIST
FIELDITEM -> FIELD COLON VALUE
FIELDITEM -> FIELD COLON OPERATOR 
FIELDITEM -> OPERATOR COLON LIST
VALUE -> LIST 
VALUE -> SET 
VALUE -> ID
OPERATOR -> DOLLARSIGN ID
FIELD -> ID
OPTION -> LIST 
LIST -> THIRDBRACKETLEFT SETS THIRDBRACKETRIGHT
SETS -> EMPTY 
SETS -> SETLIST 
SETLIST -> SET 
SETLIST -> SET COMMA SETLIST




Done steps:




Next steps:
- Convert the dfa to use a generic type. Pass in a name to be used in it.



When creating a DFA, pass a function called infoParser([]string{}) where each item in the array passed
is a line in the section

Have a section called Info where it will be like

- StateID
- Info


.StateInfos
.StateInfo
- StateID 1
- Info 1
- Info 2 
- ...
- Info n 
.StateInfo 
- StateID 2
- Info 1
- Info 2 
- ...
- Info n 


For scanners, it will be like,

.StateInfos
.StateInfo
- 1
- ID
.StateInfo 
- 2
- INT
.StateInfo 
- 3 
- FIRSTBRACKETLEFT


For parsers, it will be like,
.StateInfos 
.StateInfo 
- 1
- START -> * BOF COMMAND EOF
.StateInfo
- 2
- COMMAND -> * DBNAME DOT COLLECTIONNAME DOT COLLECTIONCOMMAND

Then we will have transitions for both :DDDD



In scanner,

States -> 
    Accepting -> Represents a token, we retrieve the token, put the thing onto the list 
    of seen tokens, and then restart from first state 



In parser,

States ->
    Accepting -> We rather pop to the last one. 



So cannot be combined.




.STATES
START
ID !
INT !
...
.TRANSITIONS
START ( FIRSTBRACKETLEFT
START ) FIRSTBRACKETRIGHT 
...
.END



START -> BOF COMMAND EOF
COMMAND -> DBNAME DOT COLLECTIONNAME DOT COLLECTIONCOMMAND



// Generate the following using the parser.cfg


.STATES 
.STATE // Implicitly track state number 
START -> * BOF COMMAND EOF
.STATE 
START -> BOF * COMMAND EOF
COMMAND -> * DBNAME DOT COLLECTIONNAME DOT COLLECTIONCOMMAND
DBNAME -> * ID
.STATE ! // Implies terminating state so will be used to pop afterwards
DBNAME -> ID *
...
.TRANSITIONS
1 BOF 2
2 ID 3
...
.END

// Separately handle EMPTY



I guess just do this in memory



start -> BOF list EOF 
list -> 


START -> BOF LIST EOF 
LIST -> LPAREN OPTIONS RPAREN
OPTIONS -> EMPTY
OPTIONS -> OPTIONLIST
OPTIONLIST -> OPTION
OPTIONLIST -> OPTION COMMA OPTIONLIST


LPAREN RPAREN 


